    @Test
    public void testDataCorruptionDetection() throws IOException
    {
        String CONTENT = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam vitae.";

        File file = new File("testDataCorruptionDetection");
        file.deleteOnExit();

        File metadata = new File(file.getPath() + ".meta");
        metadata.deleteOnExit();

        assertTrue(file.createNewFile());
        assertTrue(metadata.createNewFile());

        MetadataCollector sstableMetadataCollector = new MetadataCollector(new ClusteringComparator(BytesType.instance));
        try (SequentialWriter writer = new CompressedSequentialWriter(file, metadata.getPath(),
                                                                      null, SequentialWriterOption.DEFAULT,
                                                                      CompressionParams.snappy(), sstableMetadataCollector))
        {
            writer.write(CONTENT.getBytes());
            writer.finish();
        }

        try(ChannelProxy channel = new ChannelProxy(file))
        {
            // open compression metadata and get chunk information
            CompressionMetadata meta = new CompressionMetadata(metadata.getPath(), file.length(), ChecksumType.CRC32);
            CompressionMetadata.Chunk chunk = meta.chunkFor(0);

            try(RandomAccessReader reader = RandomAccessReader.builder(channel).compression(meta).build())
            {// read and verify compressed data
                assertEquals(CONTENT, reader.readLine());

                Random random = new Random();
                RandomAccessFile checksumModifier = null;

                try
                {
                    checksumModifier = new RandomAccessFile(file, "rw");
                    byte[] checksum = new byte[4];

                    // seek to the end of the compressed chunk
                    checksumModifier.seek(chunk.length);
                    // read checksum bytes
                    checksumModifier.read(checksum);
                    // seek back to the chunk end
                    checksumModifier.seek(chunk.length);

                    // lets modify one byte of the checksum on each iteration
                    for (int i = 0; i < checksum.length; i++)
                    {
                        checksumModifier.write(random.nextInt());
                        SyncUtil.sync(checksumModifier); // making sure that change was synced with disk

                        try (final RandomAccessReader r = RandomAccessReader.builder(channel).compression(meta).build())
                        {
                            Throwable exception = null;
                            try
                            {
                                r.readLine();
                            }
                            catch (Throwable t)
                            {
                                exception = t;
                            }
                            assertNotNull(exception);
                            assertSame(exception.getClass(), CorruptSSTableException.class);
                            assertSame(exception.getCause().getClass(), CorruptBlockException.class);
                        }
                    }

                    // lets write original checksum and check if we can read data
                    updateChecksum(checksumModifier, chunk.length, checksum);

                    try (RandomAccessReader cr = RandomAccessReader.builder(channel).compression(meta).build())
                    {
                        // read and verify compressed data
                        assertEquals(CONTENT, cr.readLine());
                        // close reader
                    }
                }
                finally
                {
                    if (checksumModifier != null)
                        checksumModifier.close();
                }
            }
        }
    }

