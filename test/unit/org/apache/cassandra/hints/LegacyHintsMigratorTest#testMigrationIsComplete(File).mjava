    private static void testMigrationIsComplete(File directory)
    {
        long timestamp = System.currentTimeMillis();

        // write 100 mutations for each of the 10 generated endpoints
        Map<UUID, Queue<Mutation>> mutations = new HashMap<>();
        for (int i = 0; i < 10; i++)
        {
            UUID hostId = UUID.randomUUID();
            Queue<Mutation> queue = new LinkedList<>();
            mutations.put(hostId, queue);

            for (int j = 0; j < 100; j++)
            {
                Mutation mutation = createMutation(j, timestamp + j);
                queue.offer(mutation);
                Mutation legacyHint = createLegacyHint(mutation, timestamp, hostId);
                legacyHint.applyUnsafe();
            }
        }

        // run the migration
        new LegacyHintsMigrator(directory, 128 * 1024 * 1024).migrate();

        // validate that the hints table is truncated now
        assertTrue(Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.LEGACY_HINTS).isEmpty());

        HintsCatalog catalog = HintsCatalog.load(directory, HintsService.EMPTY_PARAMS);

        // assert that we've correctly loaded 10 hints stores
        assertEquals(10, catalog.stores().count());

        // for each of the 10 stores, make sure the mutations have been migrated correctly
        for (Map.Entry<UUID, Queue<Mutation>> entry : mutations.entrySet())
        {
            HintsStore store = catalog.get(entry.getKey());
            assertNotNull(store);

            HintsDescriptor descriptor = store.poll();
            assertNotNull(descriptor);

            // read all the hints
            Queue<Hint> actualHints = new LinkedList<>();
            try (HintsReader reader = HintsReader.open(new File(directory, descriptor.fileName())))
            {
                for (HintsReader.Page page : reader)
                    page.hintsIterator().forEachRemaining(actualHints::offer);
            }

            // assert the size matches
            assertEquals(100, actualHints.size());

            // compare expected hints to actual hints
            for (int i = 0; i < 100; i++)
            {
                Hint hint = actualHints.poll();
                Mutation mutation = entry.getValue().poll();
                int ttl = mutation.smallestGCGS();

                assertEquals(timestamp, hint.creationTime);
                assertEquals(ttl, hint.gcgs);
                assertTrue(mutation + " != " + hint.mutation, Util.sameContent(mutation, hint.mutation));
            }
        }
    }

