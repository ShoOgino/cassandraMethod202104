    @Test
    public void testCli() throws IOException, TException, TimedOutException, NotFoundException, SchemaDisagreementException, NoSuchFieldException, InvalidRequestException, UnavailableException, InstantiationException, IllegalAccessException
    {
        Schema.instance.clear(); // Schema are now written on disk and will be reloaded
        new EmbeddedCassandraService().start();

        // new error/output streams for CliSessionState
        ByteArrayOutputStream errStream = new ByteArrayOutputStream();
        ByteArrayOutputStream outStream = new ByteArrayOutputStream();

        // checking if we can connect to the running cassandra node on localhost
        CliMain.connect("127.0.0.1", DatabaseDescriptor.getRpcPort());

        // setting new output stream
        CliMain.sessionState.setOut(new PrintStream(outStream));
        CliMain.sessionState.setErr(new PrintStream(errStream));

        // re-creating keyspace for tests
        try
        {
            // dropping in case it exists e.g. could be left from previous run
            CliMain.processStatement("drop keyspace TestKeySpace;");
        }
        catch (Exception e)
        {
            // TODO check before drop so we don't have this fragile ignored exception block
        }
        CliMain.processStatement("create keyspace TestKeySpace;");

        for (String statement : statements)
        {
            errStream.reset();
            // System.out.println("Executing statement: " + statement);
            CliMain.processStatement(statement);
            String result = outStream.toString();
            // System.out.println("Result:\n" + result);
            if (statement.startsWith("show schema"))
                assertEquals(errStream.toString() + "processing" + statement,
                             "\nWARNING: CQL3 tables are intentionally omitted from 'show schema' output." + String.format("%n")
                             + "See https://issues.apache.org/jira/browse/CASSANDRA-4377 for details.\n" + String.format("%n"),
                             errStream.toString());
            else
                assertEquals(errStream.toString() + " processing " + statement, "", errStream.toString());

            if (statement.startsWith("drop ") || statement.startsWith("create ") || statement.startsWith("update "))
            {
                assert Pattern.compile("(.{8})-(.{4})-(.{4})-(.{4})-(.{12}).*", Pattern.DOTALL).matcher(result).matches()
                       : String.format("\"%s\" failed: %s", statement, result);
            }
            else if (statement.startsWith("set "))
            {
                 assertTrue(result.contains("Value inserted."));
                 assertTrue(result.contains("Elapsed time:"));
            }
            else if (statement.startsWith("incr "))
            {
                 assertTrue(result.contains("Value incremented."));
            }
            else if (statement.startsWith("decr "))
            {
                 assertTrue(result.contains("Value decremented."));
            }
            else if (statement.startsWith("get "))
            {
                if (statement.contains("where"))
                {
                    assertTrue(result.startsWith("-------------------" + System.getProperty("line.separator") + "RowKey:"));
                }
                else if (statement.contains("Counter"))
                {
                    assertTrue(result.startsWith("=> (counter=") || result.startsWith("Value was not found"));
                }
                else
                {
                    assertTrue(result.startsWith("=> (name=") || result.startsWith("Value was not found"));
                }
                assertTrue(result.contains("Elapsed time:"));
            }
            else if (statement.startsWith("truncate "))
            {
                assertTrue(result.contains(" truncated."));
            }
            else if (statement.startsWith("assume "))
            {
                assertTrue(result.contains("successfully."));
            }

            outStream.reset(); // reset stream so we have only output from next statement all the time
            errStream.reset(); // no errors to the end user.
        }
    }

