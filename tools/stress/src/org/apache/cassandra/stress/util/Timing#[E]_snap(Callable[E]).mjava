    public <E> TimingResult<E> snap(Callable<E> call) throws InterruptedException
    {
        // Count up total # of timers
        int timerCount = 0;
        for (List<Timer> timersForOperation : timers.values())
        {
            timerCount += timersForOperation.size();
        }
        final CountDownLatch ready = new CountDownLatch(timerCount);

        // request reports
        for (List <Timer> timersForOperation : timers.values())
        {
            for(Timer timer : timersForOperation)
            {
                timer.requestReport(ready);
            }
        }

        E extra;
        try
        {
            extra = call.call();
        }
        catch (Exception e)
        {
            if (e instanceof InterruptedException)
                throw (InterruptedException) e;
            throw new RuntimeException(e);
        }

        // TODO fail gracefully after timeout if a thread is stuck
        if (!ready.await(5L, TimeUnit.MINUTES))
        {
            throw new RuntimeException("Timed out waiting for a timer thread - seems one got stuck. Check GC/Heap size");
        }

        boolean done = true;

        // reports have been filled in by timer threadCount, so merge
        Map<String, TimingInterval> intervals = new TreeMap<>();
        for (Map.Entry<String, List<Timer>> entry : timers.entrySet())
        {
            List<TimingInterval> operationIntervals = new ArrayList<>();
            for (Timer timer : entry.getValue())
            {
                operationIntervals.add(timer.report);
                done &= !timer.running();
            }

            intervals.put(entry.getKey(), TimingInterval.merge(operationIntervals,
                                                              history.get(entry.getKey()).endNanos()));
        }

        TimingIntervals result = new TimingIntervals(intervals);
        this.done = done;
        history = history.merge(result, history.startNanos());
        return new TimingResult<>(extra, result);
    }

