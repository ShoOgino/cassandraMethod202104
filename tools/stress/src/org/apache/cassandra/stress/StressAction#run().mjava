    public void run()
    {
        Snapshot latency;
        long oldLatency;
        int epoch, total, oldTotal, keyCount, oldKeyCount;

        // creating keyspace and column families
        if (client.getOperation() == Stress.Operations.INSERT || client.getOperation() == Stress.Operations.COUNTER_ADD)
            client.createKeySpaces();

        int threadCount = client.getThreads();
        Consumer[] consumers = new Consumer[threadCount];

        output.println("total,interval_op_rate,interval_key_rate,latency,95th,99th,elapsed_time");

        int itemsPerThread = client.getKeysPerThread();
        int modulo = client.getNumKeys() % threadCount;
        RateLimiter rateLimiter = RateLimiter.create(client.getMaxOpsPerSecond());

        // creating required type of the threads for the test
        for (int i = 0; i < threadCount; i++) {
            if (i == threadCount - 1)
                itemsPerThread += modulo; // last one is going to handle N + modulo items

            consumers[i] = new Consumer(itemsPerThread, rateLimiter);
        }

        Producer producer = new Producer();
        producer.start();

        // starting worker threads
        for (int i = 0; i < threadCount; i++)
            consumers[i].start();

        // initialization of the values
        boolean terminate = false;
        epoch = total = keyCount = 0;

        int interval = client.getProgressInterval();
        int epochIntervals = client.getProgressInterval() * 10;
        long testStartTime = System.nanoTime();
        
        StressStatistics stats = new StressStatistics(client, output);

        while (!terminate)
        {
            if (stop)
            {
                producer.stopProducer();

                for (Consumer consumer : consumers)
                    consumer.stopConsume();

                break;
            }

            Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);

            int alive = 0;
            for (Thread thread : consumers)
                if (thread.isAlive()) alive++;

            if (alive == 0)
                terminate = true;

            epoch++;

            if (terminate || epoch > epochIntervals)
            {
                epoch = 0;

                oldTotal = total;
                oldKeyCount = keyCount;

                total = client.operations.get();
                keyCount = client.keys.get();
                latency = client.latency.getSnapshot();

                int opDelta = total - oldTotal;
                int keyDelta = keyCount - oldKeyCount;

                long currentTimeInSeconds = TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - testStartTime);

                output.println(String.format("%d,%d,%d,%.1f,%.1f,%.1f,%d",
                                             total,
                                             opDelta / interval,
                                             keyDelta / interval,
                                             StressStatistics.nanosToMillis(latency.getMedian()), 
                                             StressStatistics.nanosToMillis(latency.get95thPercentile()), 
                                             StressStatistics.nanosToMillis(latency.get999thPercentile()),
                                             currentTimeInSeconds));

                if (client.outputStatistics()) {
                    stats.addIntervalStats(total, 
                                           opDelta / interval, 
                                           keyDelta / interval, 
                                           latency, 
                                           currentTimeInSeconds);
                        }
            }
        }

        // if any consumer failed, set the return code to failure.
        returnCode = SUCCESS;
        if (producer.isAlive())
        {
            producer.interrupt(); // if producer is still alive it means that we had errors in the consumers
            returnCode = FAILURE;
        }
        for (Consumer consumer : consumers)
            if (consumer.getReturnCode() == FAILURE)
                returnCode = FAILURE;

        if (returnCode == SUCCESS) {            
            if (client.outputStatistics())
                stats.printStats();
            // marking an end of the output to the client
            output.println("END");            
        } else {
            output.println("FAILURE");
        }

    }

