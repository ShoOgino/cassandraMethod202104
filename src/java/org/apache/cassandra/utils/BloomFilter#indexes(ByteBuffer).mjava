    // note that this method uses the threadLocal that may be longer than hashCount
    // to avoid generating a lot of garbage since stack allocation currently does not support stores
    // (CASSANDRA-6609).  it returns the array so that the caller does not need to perform
    // a second threadlocal lookup.
    private long[] indexes(ByteBuffer key)
    {
        // we use the same array both for storing the hash result, and for storing the indexes we return,
        // so that we do not need to allocate two arrays.
        long[] indexes = reusableIndexes.get();
        hash(key, key.position(), key.remaining(), 0L, indexes);
        setIndexes(indexes[0], indexes[1], hashCount, bitset.capacity(), indexes);
        return indexes;
    }

