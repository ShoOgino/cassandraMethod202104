    private SortedSet<CellName> getRequestedColumns(QueryOptions options) throws InvalidRequestException
    {
        // Note: getRequestedColumns don't handle static columns, but due to CASSANDRA-5762
        // we always do a slice for CQL3 tables, so it's ok to ignore them here
        assert !isColumnRange();

        CBuilder builder = cfm.comparator.prefixBuilder();

        Iterator<ColumnDefinition> columnIter = cfm.clusteringColumns().iterator();
        while (columnIter.hasNext())
        {
            ColumnDefinition def = columnIter.next();
            Restriction r = columnRestrictions[def.position()];
            assert r != null && !r.isSlice();

            if (r.isEQ())
            {
                List<ByteBuffer> values = r.values(options);
                if (r.isMultiColumn())
                {
                    for (int i = 0, m = values.size(); i < m; i++)
                    {
                        ByteBuffer val = values.get(i);

                        if (i != 0)
                            columnIter.next();

                        if (val == null)
                            throw new InvalidRequestException(String.format("Invalid null value for clustering key part %s", def.name));
                        builder.add(val);
                    }
                }
                else
                {
                    ByteBuffer val = r.values(options).get(0);
                    if (val == null)
                        throw new InvalidRequestException(String.format("Invalid null value for clustering key part %s", def.name));
                    builder.add(val);
                }
            }
            else
            {
                if (!r.isMultiColumn())
                {
                    List<ByteBuffer> values = r.values(options);
                    // We have a IN, which we only support for the last column.
                    // If compact, just add all values and we're done. Otherwise,
                    // for each value of the IN, creates all the columns corresponding to the selection.
                    if (values.isEmpty())
                        return null;
                    SortedSet<CellName> columns = new TreeSet<CellName>(cfm.comparator);
                    Iterator<ByteBuffer> iter = values.iterator();
                    while (iter.hasNext())
                    {
                        ByteBuffer val = iter.next();
                        if (val == null)
                            throw new InvalidRequestException(String.format("Invalid null value for clustering key part %s", def.name));

                        if (ignoreInValue(val))
                            continue;

                        Composite prefix = builder.buildWith(val);
                        columns.addAll(addSelectedColumns(prefix));
                    }
                    return columns;
                }

                // we have a multi-column IN restriction
                List<List<ByteBuffer>> values = ((MultiColumnRestriction.IN) r).splitValues(options);
                TreeSet<CellName> inValues = new TreeSet<>(cfm.comparator);
                for (List<ByteBuffer> components : values)
                {
                    for (int i = 0; i < components.size(); i++)
                        if (components.get(i) == null)
                            throw new InvalidRequestException("Invalid null value in condition for column "
                                    + cfm.clusteringColumns().get(i + def.position()).name);

                    if (ignoreInValue(components))
                        continue;

                    Composite prefix = builder.buildWith(components);
                    inValues.addAll(addSelectedColumns(prefix));
                }
                return inValues;
            }
        }

        return addSelectedColumns(builder.build());
    }

