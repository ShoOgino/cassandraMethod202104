    /**
     * Whether 2 values satisfy this operator (given the type they should be compared with).
     *
     * @throws AssertionError for CONTAINS and CONTAINS_KEY as this doesn't support those operators yet
     */
    public boolean isSatisfiedBy(AbstractType<?> type, ByteBuffer leftOperand, ByteBuffer rightOperand)
    {
        switch (this)
        {
            case EQ:
                return type.compareForCQL(leftOperand, rightOperand) == 0;
            case LT:
                return type.compareForCQL(leftOperand, rightOperand) < 0;
            case LTE:
                return type.compareForCQL(leftOperand, rightOperand) <= 0;
            case GT:
                return type.compareForCQL(leftOperand, rightOperand) > 0;
            case GTE:
                return type.compareForCQL(leftOperand, rightOperand) >= 0;
            case NEQ:
                return type.compareForCQL(leftOperand, rightOperand) != 0;
            case IN:
                List inValues = ((List) ListType.getInstance(type, false).getSerializer().deserialize(rightOperand));
                return inValues.contains(type.getSerializer().deserialize(leftOperand));
            case CONTAINS:
                if (type instanceof ListType)
                {
                    List list = (List) type.getSerializer().deserialize(leftOperand);
                    return list.contains(((ListType) type).getElementsType().getSerializer().deserialize(rightOperand));
                }
                else if (type instanceof SetType)
                {
                    Set set = (Set) type.getSerializer().deserialize(leftOperand);
                    return set.contains(((SetType) type).getElementsType().getSerializer().deserialize(rightOperand));
                }
                else  // MapType
                {
                    Map map = (Map) type.getSerializer().deserialize(leftOperand);
                    return map.containsValue(((MapType) type).getValuesType().getSerializer().deserialize(rightOperand));
                }
            case CONTAINS_KEY:
                Map map = (Map) type.getSerializer().deserialize(leftOperand);
                return map.containsKey(((MapType) type).getKeysType().getSerializer().deserialize(rightOperand));
            case LIKE_PREFIX:
                return ByteBufferUtil.startsWith(leftOperand, rightOperand);
            case LIKE_SUFFIX:
                return ByteBufferUtil.endsWith(leftOperand, rightOperand);
            case LIKE_MATCHES:
            case LIKE_CONTAINS:
                return ByteBufferUtil.contains(leftOperand, rightOperand);
            default:
                // we shouldn't get LIKE, CONTAINS, CONTAINS KEY, or IS NOT here
                throw new AssertionError();
        }
    }

