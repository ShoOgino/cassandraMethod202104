    private SSTableReader writeSortedContents(File sstableDirectory)
    {
        logger.info("Writing {}", Memtable.this.toString());

        SSTableReader ssTable;
        // errors when creating the writer that may leave empty temp files.
        try (SSTableWriter writer = createFlushWriter(cfs.getTempSSTablePath(sstableDirectory)))
        {
            boolean trackContention = logger.isTraceEnabled();
            int heavilyContendedRowCount = 0;
            // (we can't clear out the map as-we-go to free up memory,
            //  since the memtable is being used for queries in the "pending flush" category)
            for (Map.Entry<RowPosition, AtomicBTreeColumns> entry : rows.entrySet())
            {
                AtomicBTreeColumns cf = entry.getValue();

                if (cf.isMarkedForDelete() && cf.hasColumns())
                {
                    // When every node is up, there's no reason to write batchlog data out to sstables
                    // (which in turn incurs cost like compaction) since the BL write + delete cancel each other out,
                    // and BL data is strictly local, so we don't need to preserve tombstones for repair.
                    // If we have a data row + row level tombstone, then writing it is effectively an expensive no-op so we skip it.
                    // See CASSANDRA-4667.
                    if (cfs.name.equals(SystemKeyspace.BATCHLOG) && cfs.keyspace.getName().equals(SystemKeyspace.NAME))
                        continue;
                }

                if (trackContention && cf.usePessimisticLocking())
                    heavilyContendedRowCount++;

                if (!cf.isEmpty())
                    writer.append((DecoratedKey)entry.getKey(), cf);
            }

            if (writer.getFilePointer() > 0)
            {
                logger.debug(String.format("Completed flushing %s (%s) for commitlog position %s",
                                           writer.getFilename(),
                                           FBUtilities.prettyPrintMemory(writer.getOnDiskFilePointer()),
                                           commitLogUpperBound));

                // temp sstables should contain non-repaired data.
                ssTable = writer.finish(true);
            }
            else
            {
                logger.debug("Completed flushing {}; nothing needed to be retained.  Commitlog position was {}",
                             writer.getFilename(), commitLogUpperBound);
                writer.abort();
                ssTable = null;
            }

            if (heavilyContendedRowCount > 0)
                logger.trace(String.format("High update contention in %d/%d partitions of %s ", heavilyContendedRowCount, rows.size(), Memtable.this.toString()));

            return ssTable;
        }
    }

