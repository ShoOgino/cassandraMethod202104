        public boolean isSatisfiedBy(DecoratedKey rowKey, ColumnFamily data, ColumnNameBuilder builder)
        {
            // We enforces even the primary clause because reads are not synchronized with writes and it is thus possible to have a race
            // where the index returned a row which doesn't have the primary column when we actually read it
            for (IndexExpression expression : clause)
            {
                ColumnDefinition def = data.metadata().getColumnDefinition(expression.column);
                ByteBuffer dataValue = null;
                AbstractType<?> validator = null;
                if (def == null)
                {
                    // This can't happen with CQL3 as this should be rejected upfront. For thrift however,
                    // column name are not predefined. But that means the column name correspond to an internal one.
                    Column column = data.getColumn(expression.column);
                    if (column != null)
                    {
                        dataValue = column.value();
                        validator = data.metadata().getDefaultValidator();
                    }
                }
                else
                {
                    dataValue = extractDataValue(def, rowKey.key, data, builder);
                    validator = def.type;
                }

                if (dataValue == null)
                    return false;

                int v = validator.compare(dataValue, expression.value);
                if (!satisfies(v, expression.operator))
                    return false;
            }
            return true;
        }

