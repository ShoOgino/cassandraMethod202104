    public ScannerList getScanners(Collection<SSTableReader> sstables, Range<Token> range)
    {
        Multimap<Integer, SSTableReader> byLevel = ArrayListMultimap.create();
        for (SSTableReader sstable : sstables)
        {
            if (manifest.hasRepairedData() && !sstable.isRepaired())
                byLevel.get(0).add(sstable);
            else
                byLevel.get(sstable.getSSTableLevel()).add(sstable);
        }

        List<ICompactionScanner> scanners = new ArrayList<ICompactionScanner>(sstables.size());
        try
        {
            for (Integer level : byLevel.keySet())
            {
                // level can be -1 when sstables are added to DataTracker but not to LeveledManifest
                // since we don't know which level those sstable belong yet, we simply do the same as L0 sstables.
                if (level <= 0)
                {
                    // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
                    for (SSTableReader sstable : byLevel.get(level))
                        scanners.add(sstable.getScanner(range, CompactionManager.instance.getRateLimiter()));
                }
                else
                {
                    // Create a LeveledScanner that only opens one sstable at a time, in sorted order
                    List<SSTableReader> intersecting = LeveledScanner.intersecting(byLevel.get(level), range);
                    if (!intersecting.isEmpty())
                        scanners.add(new LeveledScanner(intersecting, range));
                }
            }
        }
        catch (Throwable t)
        {
            try
            {
                new ScannerList(scanners).close();
            }
            catch (Throwable t2)
            {
                t.addSuppressed(t2);
            }
            throw t;
        }

        return new ScannerList(scanners);
    }

