    /**
     * @return the largest timestamp before which it's okay to drop tombstones for the given partition;
     * i.e., after the maxPurgeableTimestamp there may exist newer data that still needs to be suppressed
     * in other sstables.  This returns the minimum timestamp for any SSTable that contains this partition and is not
     * participating in this compaction, or memtable that contains this partition,
     * or LONG.MAX_VALUE if no SSTable or memtable exist.
     */
    public long maxPurgeableTimestamp(DecoratedKey key)
    {
        if (!compactingRepaired() || NEVER_PURGE_TOMBSTONES)
            return Long.MIN_VALUE;

        long min = Long.MAX_VALUE;
        overlapIterator.update(key);
        for (SSTableReader sstable : overlapIterator.overlaps())
        {
            // if we don't have bloom filter(bf_fp_chance=1.0 or filter file is missing),
            // we check index file instead.
            if ((sstable.getBloomFilter() instanceof AlwaysPresentFilter && sstable.getPosition(key, SSTableReader.Operator.EQ, false) != null)
                || sstable.getBloomFilter().isPresent(key))
                min = Math.min(min, sstable.getMinTimestamp());
        }

        for (Memtable memtable : cfs.getTracker().getView().getAllMemtables())
        {
            Partition partition = memtable.getPartition(key);
            if (partition != null)
                min = Math.min(min, partition.stats().minTimestamp);
        }
        return min;
    }

