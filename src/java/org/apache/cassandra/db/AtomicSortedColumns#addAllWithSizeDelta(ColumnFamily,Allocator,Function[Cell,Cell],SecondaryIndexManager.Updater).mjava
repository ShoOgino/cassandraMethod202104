    /**
     *  This is only called by Memtable.resolve, so only AtomicSortedColumns needs to implement it.
     *
     *  @return the difference in size seen after merging the given columns
     */
    public long addAllWithSizeDelta(ColumnFamily cm, Allocator allocator, Function<Cell, Cell> transformation, SecondaryIndexManager.Updater indexer)
    {
        /*
         * This operation needs to atomicity and isolation. To that end, we
         * add the new column to a copy of the map (a cheap O(1) snapTree
         * clone) and atomically compare and swap when everything has been
         * added. Of course, we must not forget to update the deletion times
         * too.
         * In case we are adding a lot of columns, failing the final compare
         * and swap could be expensive. To mitigate, we check we haven't been
         * beaten by another thread after every column addition. If we have,
         * we bail early, avoiding unnecessary work if possible.
         */
        Holder current, modified;
        long sizeDelta;

        main_loop:
        do
        {
            sizeDelta = 0;
            current = ref;
            DeletionInfo newDelInfo = current.deletionInfo.copy().add(cm.deletionInfo());
            modified = new Holder(current.map.clone(), newDelInfo);

            if (cm.deletionInfo().hasRanges())
            {
                for (Cell currentCell : Iterables.concat(current.map.values(), cm))
                {
                    if (cm.deletionInfo().isDeleted(currentCell))
                        indexer.remove(currentCell);
                }
            }

            for (Cell cell : cm)
            {
                sizeDelta += modified.addColumn(transformation.apply(cell), allocator, indexer);
                // bail early if we know we've been beaten
                if (ref != current)
                    continue main_loop;
            }
        }
        while (!refUpdater.compareAndSet(this, current, modified));

        indexer.updateRowLevelIndexes();

        return sizeDelta;
    }

