    /**
     * Truncate deletes the entire column family's data with no expensive tombstone creation
     */
    public void truncateBlocking()
    {
        // We have two goals here:
        // - truncate should delete everything written before truncate was invoked
        // - but not delete anything that isn't part of the snapshot we create.
        // We accomplish this by first flushing manually, then snapshotting, and
        // recording the timestamp IN BETWEEN those actions. Any sstables created
        // with this timestamp or greater time, will not be marked for delete.
        //
        // Bonus complication: since we store replay position in sstable metadata,
        // truncating those sstables means we will replay any CL segments from the
        // beginning if we restart before they [the CL segments] are discarded for
        // normal reasons post-truncate.  To prevent this, we store truncation
        // position in the System keyspace.
        logger.trace("truncating {}", name);

        final long truncatedAt;
        final ReplayPosition replayAfter;

        synchronized (data)
        {
            if (keyspace.getMetadata().params.durableWrites || DatabaseDescriptor.isAutoSnapshot())
            {
                replayAfter = forceBlockingFlush();
                viewManager.forceBlockingFlush();
            }
            else
            {
                // just nuke the memtable data w/o writing to disk first
                viewManager.dumpMemtables();
                try
                {
                    replayAfter = dumpMemtable().get();
                }
                catch (Exception e)
                {
                    throw new RuntimeException(e);
                }
            }

            long now = System.currentTimeMillis();
            // make sure none of our sstables are somehow in the future (clock drift, perhaps)
            for (ColumnFamilyStore cfs : concatWithIndexes())
                for (SSTableReader sstable : cfs.data.getSSTables())
                    now = Math.max(now, sstable.maxDataAge);
            truncatedAt = now;
        }

        Runnable truncateRunnable = new Runnable()
        {
            public void run()
            {
                logger.debug("Discarding sstable data for truncated CF + indexes");
                data.notifyTruncated(truncatedAt);

                if (DatabaseDescriptor.isAutoSnapshot())
                    snapshot(Keyspace.getTimestampedSnapshotName(name));

                discardSSTables(truncatedAt);

                indexManager.truncateAllIndexesBlocking(truncatedAt);
                viewManager.truncateBlocking(replayAfter, truncatedAt);

                SystemKeyspace.saveTruncationRecord(ColumnFamilyStore.this, truncatedAt, replayAfter);
                logger.trace("cleaning out row cache");
                invalidateCaches();
            }
        };

        runWithCompactionsDisabled(Executors.callable(truncateRunnable), true, true);
        logger.trace("truncate complete");
    }

