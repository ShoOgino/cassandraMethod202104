    private void tidy(boolean release)
    {
        if (readMeterSyncFuture != null)
            readMeterSyncFuture.cancel(false);

        if (references.get() != 0)
        {
            throw new IllegalStateException("SSTable is not fully released (" + references.get() + " references)");
        }

        synchronized (replaceLock)
        {
            boolean closeBf = true, closeSummary = true, closeFiles = true, deleteFile = false;

            if (replacedBy != null)
            {
                closeBf = replacedBy.bf != bf;
                closeSummary = replacedBy.indexSummary != indexSummary;
                closeFiles = replacedBy.dfile != dfile;
                // if the replacement sstablereader uses a different path, clean up our paths
                deleteFile = !dfile.path.equals(replacedBy.dfile.path);
            }

            if (replaces != null)
            {
                closeBf &= replaces.bf != bf;
                closeSummary &= replaces.indexSummary != indexSummary;
                closeFiles &= replaces.dfile != dfile;
                deleteFile &= !dfile.path.equals(replaces.dfile.path);
            }

            boolean deleteAll = false;
            if (release && isCompacted.get())
            {
                assert replacedBy == null;
                if (replaces != null)
                {
                    replaces.replacedBy = null;
                    replaces.deletingTask = deletingTask;
                    replaces.markObsolete();
                }
                else
                {
                    deleteAll = true;
                }
            }
            else
            {
                if (replaces != null)
                    replaces.replacedBy = replacedBy;
                if (replacedBy != null)
                    replacedBy.replaces = replaces;
            }

            scheduleTidy(closeBf, closeSummary, closeFiles, deleteFile, deleteAll);
        }
    }

