    MultiPartitionPager(List<ReadCommand> commands, ConsistencyLevel consistencyLevel, boolean localQuery, PagingState state)
    {
        int i = 0;
        // If it's not the beginning (state != null), we need to find where we were and skip previous commands
        // since they are done.
        if (state != null)
            for (; i < commands.size(); i++)
                if (commands.get(i).key.equals(state.partitionKey))
                    break;

        if (i >= commands.size())
        {
            pagers = null;
            timestamp = -1;
            return;
        }

        pagers = new SinglePartitionPager[commands.size() - i];
        // 'i' is on the first non exhausted pager for the previous page (or the first one)
        pagers[0] = makePager(commands.get(i), consistencyLevel, localQuery, state);
        timestamp = commands.get(i).timestamp;

        // Following ones haven't been started yet
        for (int j = i + 1; j < commands.size(); j++)
        {
            ReadCommand command = commands.get(j);
            if (command.timestamp != timestamp)
                throw new IllegalArgumentException("All commands must have the same timestamp or weird results may happen.");
            pagers[j - i] = makePager(command, consistencyLevel, localQuery, null);
        }
        remaining = state == null ? computeRemaining(pagers) : state.remaining;
    }

