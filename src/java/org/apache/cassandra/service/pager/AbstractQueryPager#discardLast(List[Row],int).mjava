    @VisibleForTesting
    List<Row> discardLast(List<Row> rows, int toDiscard)
    {
        if (toDiscard == 0 || rows.isEmpty())
            return rows;

        int i = rows.size()-1;
        DecoratedKey lastKey = null;
        ColumnFamily lastCf = null;
        while (toDiscard > 0 && i >= 0)
        {
            Row last = rows.get(i--);
            lastKey = last.key;
            lastCf = last.cf.cloneMeShallow();
            toDiscard -= isReversed()
                       ? discardFirst(last.cf, toDiscard, lastCf)
                       : discardLast(last.cf, toDiscard, lastCf);
        }

        // If there is less live data than to discard, all is discarded
        if (toDiscard > 0)
            return Collections.<Row>emptyList();

        // i is the index of the last row that we are sure to keep. On top of that,
        // we also keep lastCf is it hasn't been fully emptied by the last iteration above.
        int count = lastCf.getColumnCount();
        int newSize = count == 0 ? i+1 : i+2;
        List<Row> newRows = new ArrayList<Row>(newSize);
        newRows.addAll(rows.subList(0, i+1));
        if (count != 0)
            newRows.add(new Row(lastKey, lastCf));

        return newRows;
    }

